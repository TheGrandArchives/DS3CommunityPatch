<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="26">
  <CheatEntries>
    <CheatEntry>
      <ID>1337037379</ID>
      <Description>"TGA Community Patch v0.1 (Regulation 1.35, Game v1.15)"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START PatchInfo class
	Author: Igromanru
	Description: Entity with informations (address, value and valueType).
					Also enum TYPE, with all possible value types.
]]--
PatchInfo = {
	address = 0,
	value = 0,
	valueType = 0,
	binaryOffset = 0,
	BINARYOFFSET = {
		ONE = 1,
		TWO = 2,
		THREE = 4,
		FOUR = 8,
		FIVE = 16,
		SIX = 32,
		SEVEN = 64,
		EIGHT = 128,
	},
	TYPE = {
		BINARY = 0,
		BYTE = 1,
		TWO_BYTE = 2,
		FOUR_BYTE = 3,
		EIGHT_BYTE = 4,
		FLOAT = 5,
	}
}

function PatchInfo:new(address, value, valueType, binaryOffset)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	if(address ~= nil) then
		o.address = address
	end
	if(value ~= nil) then
		o.value = value
	end
	if(valueType ~= nil) then
		o.valueType = valueType
	end
	if(binaryOffset ~= nil) then
		o.binaryOffset = binaryOffset
	end

	return o
end

function PatchInfo:getBinaryOffset(value)
	local result = value
	if(value == 0) then
		result = PatchInfo.BINARYOFFSET.ONE
	elseif(value == 1) then
		result = PatchInfo.BINARYOFFSET.TWO
	elseif(value == 2) then
		result = PatchInfo.BINARYOFFSET.THREE
	elseif(value == 3) then
		result = PatchInfo.BINARYOFFSET.FOUR
	elseif(value == 4) then
		result = PatchInfo.BINARYOFFSET.FIVE
	elseif(value == 5) then
		result = PatchInfo.BINARYOFFSET.SIX
	elseif(value == 6) then
		result = PatchInfo.BINARYOFFSET.SEVEN
	elseif(value == 7) then
		result = PatchInfo.BINARYOFFSET.EIGHT
	end
	return result
end

--[[END PatchInfo class]]--

--[[START ParamUtils class
	Author: Igromanru
	Description: Utils class for Params
]]--
ParamUtils = {
	masterParamTable = {},
	patchBackUp = {},
    patchBackUpOld = {},
}

function ParamUtils:new()
	local function readIntegerSafe(Input)
		local Value = readInteger(Input)
		if Value &lt; 2147483647 then
			return Value
		else
			return Value - 0x100000000
		end
	end
	local function InitializeAddress()
		autoAssemble([[
			aobscanmodule(ParamPatchBase,DarkSoulsIII.exe,48 8B 0D ? ? ? ? 48 85 C9 74 0B 4C 8B C0 48 8B D7)
			registersymbol(ParamPatchBase)
		]])
		local addr = getAddress("ParamPatchBase")
		addr = addr + readIntegerSafe(addr + 0x3) + 7
		addr = readQword(addr)+ 0x10
		unregisterSymbol("ParamPatch")
		registerSymbol("ParamPatch", addr, true)
	end
	local o = {}
	setmetatable(o, self)
	self.__index = self

    InitializeAddress()
	o:paramIndexer()
	return o
end

function ParamUtils:destroy()
	unregisterSymbol("ParamPatchBase")
	unregisterSymbol("ParamPatch")
end

function ParamUtils:toHex(number, length)
	local result = ""
	if(length ~= nil and length &gt; 0) then
		result = string.format("%0"..length.."X",number)
	else
		result = string.format("%X",number)
	end
	return result
end

function ParamUtils:isEmpty(value)
  local result = value == nil
  if(not result) then
    if(type(value) == "string") then
	  result = value == ""
	elseif(type(value) == "table") then
	  result = true
	  for key,tabl in pairs(value) do
        result = key == nil
        break
      end
	end
  end
  return result
end

function ParamUtils:isNotEmpty(value)
  return not self:isEmpty(value)
end

function ParamUtils:logError(message)
	local output = "ParamUtils Error:\r\n"..message
	print(output)
	error(output)
end

function ParamUtils:paramIndexer()
	local Param = getAddress("ParamPatch")
	local Start = readQword(Param)
	local End = readQword(Param+8)
	local Count = (End-Start)/8
	self.masterParamTable = {}

	for i = 0, Count - 1 do
	  local ParamOffset = readQword(Start+i*8)
	  local ParamString = "Unknown"
	  if readInteger(ParamOffset+0x20) &gt; 7 then
		 ParamString = readString(readQword(ParamOffset+0x10),90,true)
	  else
		 ParamString = readString(ParamOffset+0x10,90,true)
	  end
	  self.masterParamTable[ParamString] = ParamOffset
	end
end

function ParamUtils:getParamAddress(param)
  return self.masterParamTable[param]
end

function ParamUtils:getIdAddress(idTable, Id)
	local result = idTable[Id]
	if(self:isEmpty(result) or result &lt; 0) then
		self:logError("ID: "..Id.." (0x"..self:toHex(Id) ..") couldn't be found")
	end
	return result
end

function ParamUtils:getIdFromAddress(idTable, address)
  local result = 0
  if(self:isNotEmpty(idTable) and self:isNotEmpty(address)) then
    for id,addr in pairs(idTable) do
	  if(addr == address) then
	    result = id
	    break
	  end
	end
  end
  if(result == 0) then
    self:logError("ID for address: "..self:toHex(address).." couldn't be found")
  end
  return result
end

function ParamUtils:getParamIdTable(ParamName)
	local IDTable = {}
	local ParamAddr = readQword(readQword(self.masterParamTable[ParamName]+0x68)+0x68)
	local TableCount = byteTableToWord(readBytes(ParamAddr+0xa,2,true))
	for i=0,TableCount-1 do
		local PID = readInteger(ParamAddr+0x40+0x18*i)
		local IDO = readInteger(ParamAddr+0x48+0x18*i)
		IDTable[PID] = ParamAddr + IDO
	end
	return IDTable
end

function ParamUtils:getIdAddressInParam(paramName, id)
	local result = 0
	local idTable = self:getParamIdTable(paramName)

	if(idTable ~= nil) then
		result = self:getIdAddress(idTable, id)
	else
		self:logError("Addresses for Param: '"..paramName.."' couldn't be found")
	end
	return result
end

function ParamUtils:getIdFromAddressInParam(paramName, address)
	local result = 0
	local idTable = self:getParamIdTable(paramName)

	if(self:isNotEmpty(idTable)) then
		result = self:getIdFromAddress(idTable, address)
	end
	return result
end

function ParamUtils:getIdByAddressInAnyParam(address)
  local result = 0
  if(self.masterParamTable ~= nil) then
    for param,paramAddr in pairs(self.masterParamTable) do
	  local idTable = self:getParamIdTable(param)
	  if(self:isNotEmpty(idTable)) then
		local id = self:getIdFromAddress(idTable, address)
		if(id &gt; 0) then
		  result = id
		  break
		end
	  end
	end
  end
  return result
end

function ParamUtils:getAllAddressFromParam(paramName)
	local result = {}
	local idTable = self:getParamIdTable(paramName)

	if(self:isNotEmpty(idTable)) then
		for id,address in pairs(idTable) do
			table.insert(result, address)
		end
	end
	return result
end

function ParamUtils:paramIterator(ParamName,ChangeTable,uuid)
	local IDTable = self:getParamIdTable(ParamName)
	if uuid ~= nil then --Make a table for backups
		if self.patchBackUpOld == nil then
			self.patchBackUpOld = {}
		end
		self.patchBackUpOld[uuid] = {}
		for k,v in pairs(ChangeTable) do
			local Backup = {}
			local _,DataLength = string.gsub(v[3], "%x+","")
			local idAddress = self:getIdAddress(IDTable,v[1])
			if self:isNotEmpty(idAddress) then
				Backup[1] = idAddress + v[2]
				Backup[2] = readBytes(Backup[1],DataLength,true)
				table.insert(self.patchBackUpOld[uuid],Backup)
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	else
		for k,v in pairs(ChangeTable) do
			local idAddress = self:getIdAddress(IDTable,v[1])
			if self:isNotEmpty(idAddress) then
				self:paramPatcher(idAddress,v[2],v[3],v[4])
			end
		end
	end
end

function ParamUtils:paramPatcher(idAddress,DataOffset,Data,Symbol)
	local WriteAddr = idAddress+DataOffset
	local HexTable = {}
	if Symbol == nil then
		for word in string.gmatch(Data, "%x+") do table.insert(HexTable,tonumber(word,16)) end
		writeBytes(WriteAddr,HexTable)
	else
		registerSymbol(Symbol,WriteAddr,true)
	end
end

function ParamUtils:paramDepatcher(uuid)
  if(self.patchBackUpOld[uuid] ~= nil) then
    for k,v in pairs(self.patchBackUpOld[uuid]) do
	  if(self:isNotEmpty(v)) then
        writeBytes(v[1],v[2])
	  end
    end
    self.patchBackUpOld[uuid] = nil
  end
end

function ParamUtils:patchMultipleOffsets(paramName, id, patchInfoTable, uuid)
	if(self.patchBackUp[uuid] == nil) then
		local address = getIdAddressInParam()
		for key,patchInfo in pairs(patchInfoTable) do
			patchInfo.address = address
			self:patchValueWithBackup(patchInfo,uuid)
		end
	else
        self:logError("The UUID "..uuid.." is already in use.")
	end
end

function ParamUtils:restore(...)
  local arg = table.pack(...)
  for key,uuid in pairs(arg) do
    if(self:isNotEmpty(self.patchBackUp[uuid])) then
      for index,patchInfo in pairs(self.patchBackUp[uuid]) do
	    self:patchValue(patchInfo)
	  end
	  self.patchBackUp[uuid] = nil
	end
  end
end

function ParamUtils:patchValueWithBackup(patchInfo, uuid)
	local readValue = self:readValue(patchInfo)
	local backup = true

	self:patchValue(patchInfo)

	for key,object in pairs(self.patchBackUp[uuid]) do
		if(object.address == patchInfo.address) then
			backup = false
			break
		end
	end
	if(backup) then
		if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
			patchInfo.valueType = PatchInfo.TYPE.BYTE
		end
		table.insert(self.patchBackUp[uuid], PatchInfo:new(patchInfo.address, readValue, patchInfo.valueType))
	end
end

function ParamUtils:readValue(patchInfo)
	local value = 0
	if(patchInfo.valueType == PatchInfo.TYPE.BYTE or patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		value = self:readByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		value = self:read2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		value = self:read4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		value = self:read8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		value = self:readFloat(patchInfo)
	end
	return value
end

function ParamUtils:patchValue(patchInfo)
	if(patchInfo.valueType == PatchInfo.TYPE.BINARY) then
		self:writeBinary(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.BYTE) then
		self:writeByte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.TWO_BYTE) then
		self:write2Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FOUR_BYTE) then
		self:write4Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.EIGHT_BYTE) then
		self:write8Byte(patchInfo)
	elseif(patchInfo.valueType == PatchInfo.TYPE.FLOAT) then
		self:writeFloat(patchInfo)
	end
end

function ParamUtils:writeBinary(patchInfo)
	if(patchInfo.binaryOffset &gt; 0) then
		local prevValue = self:readByte(patchInfo)
		if(patchInfo.value == 0) then
			patchInfo.value = bAnd(prevValue, ~patchInfo.binaryOffset)
		else
			patchInfo.value = bOr(prevValue,patchInfo.binaryOffset)
		end
		writeBytes(patchInfo.address, patchInfo.value)
	else
		self:logError("To write a binary you've to set the 'binaryOffset'")
	end
end

function ParamUtils:writeByte(patchInfo)
	if(patchInfo.value &gt; 255) then
		self:logError("Byte can't be bigger then 255")
	elseif(patchInfo.value &lt; 0) then
		self:logError("Byte can't be smaller then 0")
	else
		writeBytes(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write2Byte(patchInfo)
	if(patchInfo.value &gt; 65535) then
		self:logError("2 Bytes can't be bigger then 65535")
	elseif(patchInfo.value &lt; 0) then
		self:logError("2 Bytes can't be smaller then 0")
	else
		writeBytes(patchInfo.address, wordToByteTable(patchInfo.value))
	end
end

function ParamUtils:write4Byte(patchInfo)
	if(patchInfo.value &gt; 4294967295) then
		self:logError("4 Bytes can't be bigger then 4294967295")
	elseif(patchInfo.value &lt; -2147483648) then
		self:logError("4 Bytes can't be smaller then -2147483648")
	else
		writeInteger(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:write8Byte(patchInfo)
	if(patchInfo.value &gt; 9223372036854775807) then
		self:logError("8 Bytes can't be bigger then 9223372036854775807")
	elseif(patchInfo.value &lt; -9223372036854775808) then
		self:logError("8 Bytes can't be smaller then -9223372036854775808")
	else
		writeQword(patchInfo.address, patchInfo.value)
	end
end

function ParamUtils:writeFloat(patchInfo)
	if(patchInfo.value &gt; 3.4028235E38) then
		self:logError("Float can't be bigger then 3.4028235E38")
	elseif(patchInfo.value &lt; -3.4028235E38) then
		self:logError("Float can't be smaller then -3.4028235E38")
	else
		writeFloat(patchInfo.address, patchInfo.value)
	end
end

-- read functions
function ParamUtils:readByte(patchInfo)
	return readBytes(patchInfo.address, 1)
end

function ParamUtils:read2Byte(patchInfo)
	return byteTableToWord(readBytes(patchInfo.address, 2, true))
end

function ParamUtils:read4Byte(patchInfo)
	return readInteger(patchInfo.address)
end

function ParamUtils:read8Byte(patchInfo)
	return readQword(patchInfo.address)
end

function ParamUtils:readFloat(patchInfo)
	return readFloat(patchInfo.address)
end

function ParamUtils:restoreAllBackups()
  if(self:isNotEmpty(self.patchBackUp)) then
    for uuid,tBackup in pairs(self.patchBackUp) do
	  self:restore(uuid)
    end
  end
  self.patchBackUp = {}
end

function ParamUtils:restoreAllOldBackups()
  if(self:isNotEmpty(self.patchBackUpOld)) then
    for uuid,tBackup in pairs(self.patchBackUpOld) do
	  self:restore(uuid)
    end
  end
  self.patchBackUpOld = {}
end

function ParamUtils:printAllBackups()
  if(self:isNotEmpty(self.patchBackUp)) then
    for uuid,tBackup in pairs(self.patchBackUp) do
	  print("UUID: "..uuid)
	  for key,object in pairs(tBackup) do
	    print("Address: "..object.address.." Value: "..object.value.." Type: "..object.valueType)
	  end
    end
  end
end

function ParamUtils:printAllOldBackups()
  if(self:isNotEmpty(self.patchBackUpOld)) then
    for uuid,tBackup in pairs(self.patchBackUpOld) do
	  print("UUID: "..uuid)
	  for address,byteArray in pairs(tBackup) do
	    print("Address: "..address.." Byte Array: ")
	  end
    end
  end
end

function ParamUtils:printParams()
  if(self:isNotEmpty(self.masterParamTable)) then
    for key,address in pairs(self.masterParamTable) do
	  print("Param: "..key.." Address: "..self:toHex(address))
    end
  end
end

function ParamUtils:printParamsIds(param)
  if(self:isNotEmpty(self.masterParamTable)) then
    local idTable = self:getParamIdTable(param)
    for id,address in pairs(idTable) do
	  print("ID: "..id.." (0x"..self:toHex(id)..") Address: "..self:toHex(address))
    end
  end
end

function ParamUtils:printParamAddress(param)
  local address = self:getParamAddress(param)
  if(self:isNotEmpty(address)) then
    print("Param: "..param..", Address: "..self:toHex(address))
  else
	print("Param: "..param.." couldn't be found.")
  end
end

-- Creating an instance of ParamUtils
paramUtils = ParamUtils:new()
--[[END ParamUtils class]]--

local function enableRecord(thread, id)
  local record = getAddressList().getMemoryRecordByID(id)
  if(record ~= nil) then
    sleep(500)
    record.Active = true
  else
    print("Record with ID "..id.." doesn't exists")
  end
end
createNativeThread(enableRecord, 1337037701) --Enable PP classes

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restoreAllBackups()
paramUtils:printAllOldBackups()
paramUtils:destroy()

local function disableRecord(thread, id)
  local record = getAddressList().getMemoryRecordByID(id)
  if(record ~= nil) then
    sleep(500)
    record.Active = false
  else
    print("Record with ID "..id.." doesn't exists")
  end
end
createNativeThread(disableRecord, 1337037701) --Disable PP classes

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>1337037700</ID>
          <Description>"Classes"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <Color>E1E1E1</Color>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1337037714</ID>
              <Description>"Don't disable or change Param Patcher classes"</Description>
              <LastState Value="" RealAddress="00000000"/>
              <Color>FF0000</Color>
              <GroupHeader>1</GroupHeader>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037701</ID>
              <Description>"BaseParamClass"</Description>
              <Options moHideChildren="1" moActivateChildrenAsWell="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START BaseParamClass class]]--
BaseParamClass = {
	id = 0,
	param = "",
	backupUuid = "",
	address = 0
}

function BaseParamClass:new(param, uuid, id, address)
  local o = {}
  self.__index = self
  setmetatable(o, self)

  o:init(param, uuid, id, address)
  return o
end

function BaseParamClass:init(param, uuid, id, address)
  if(param ~= nil) then
    self.param = param
  end
  if(uuid ~= nil) then
    self.backupUuid = uuid
  end
  if(id ~= nil) then
    self.id = id
  end
  if(self.param ~= "") then
    if(paramUtils:isNotEmpty(self.backupUuid) and paramUtils:isEmpty(paramUtils.patchBackUp[self.backupUuid])) then
      paramUtils.patchBackUp[self.backupUuid] = {}
    end
	if(address ~= nil and address &gt; 0) then
	  self.address = address
    elseif(self.id ~= nil and self.id &gt; 0) then
	  self:stripSelfIdForParams()
      self.address = paramUtils:getIdAddressInParam(self.param, self.id)
    end
  end
end

-- Removes first Hex digit of the ID
function BaseParamClass:stripIdForParams(id)
	local idHex = paramUtils:toHex(id, 8)
	return tonumber(idHex:sub(2),16)
end

function BaseParamClass:stripSelfIdForParams()
  if(self.id ~= nil and self.id &gt; 0) then
    self.id = self:stripIdForParams(self.id)
  end
end

--Patch all values
function BaseParamClass:patchAll(offset, value, valueType, binaryOffset)
  local addresses = paramUtils:getAllAddressFromParam(self.param)
  for key,address in pairs(addresses) do
    local patchInfo = PatchInfo:new(address + offset, value, valueType, PatchInfo:getBinaryOffset(binaryOffset))
	if(paramUtils:isEmpty(self.backupUuid)) then
	  paramUtils:patchValue(patchInfo)
    else
      paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
    end
  end
end

function BaseParamClass:patchAllBinary(offset, value, binaryOffset)
	self:patchAll(offset, value, PatchInfo.TYPE.BINARY, binaryOffset)
end

function BaseParamClass:patchAllByte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patchAll2Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patchAll4Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patchAll8Byte(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchAllFloat(offset, value)
	self:patchAll(offset, value, PatchInfo.TYPE.FLOAT)
end

-- Patch value
function BaseParamClass:patchValue(offset, value, valueType, binaryOffset)
  local patchInfo = PatchInfo:new(self.address + offset, value, valueType, PatchInfo:getBinaryOffset(binaryOffset))
  if(paramUtils:isEmpty(self.backupUuid)) then
    paramUtils:patchValue(patchInfo)
  else
    paramUtils:patchValueWithBackup(patchInfo, self.backupUuid)
  end
end

function BaseParamClass:patchBinary(offset, value, binaryOffset)
	self:patchValue(offset, value, PatchInfo.TYPE.BINARY, binaryOffset)
end

function BaseParamClass:patchByte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:patch2Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:patch4Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:patch8Byte(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:patchFloat(offset, value)
	self:patchValue(offset, value, PatchInfo.TYPE.FLOAT)
end

-- Read value
function BaseParamClass:readValue(offset, valueType, binaryOffset)
	local patchInfo = PatchInfo:new(self.address + offset, nil, valueType, PatchInfo:getBinaryOffset(binaryOffset))
	return paramUtils:readValue(patchInfo)
end

function BaseParamClass:readBinary(offset, binaryOffset)
	local bByte = self:readValue(offset, PatchInfo.TYPE.BINARY, binaryOffset)
	return bAnd(bByte, PatchInfo:getBinaryOffset(binaryOffset)) ~= 0
end

function BaseParamClass:readByte(offset)
	return self:readValue(offset, PatchInfo.TYPE.BYTE)
end

function BaseParamClass:read2Byte(offset)
	return self:readValue(offset, PatchInfo.TYPE.TWO_BYTE)
end

function BaseParamClass:read4Byte(offset)
	return self:readValue(offset, PatchInfo.TYPE.FOUR_BYTE)
end

function BaseParamClass:read8Byte(offset)
	return self:readValue(offset, PatchInfo.TYPE.EIGHT_BYTE)
end

function BaseParamClass:readFloat(offset)
	return self:readValue(offset, PatchInfo.TYPE.FLOAT)
end

--[[END BaseParamClass class]]--

[DISABLE]
{$lua}
--if syntaxcheck then return end

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>1337037702</ID>
                  <Description>"EquipParamWeapon"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
--if syntaxcheck then return end

--[[START EquipParamWeapon class]]--
EquipParamWeapon = BaseParamClass:new()

function EquipParamWeapon:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("EquipParamWeapon", uuid, id, address)
	return o
end

function EquipParamWeapon:behaviorId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamWeapon:sortId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamWeapon:wanderingEquipId(value)
	self:patch4Byte(0x8, value)
end

-- Weight
function EquipParamWeapon:weight(value)
	self:patchFloat(0xC, value)
end

function EquipParamWeapon:weaponWeightRate(value)
	self:patchFloat(0x10, value)
end

-- Prices
function EquipParamWeapon:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamWeapon:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamWeapon:sellValue(value)
	self:patch4Byte(0x1C, value)
end

-- Scaling
function EquipParamWeapon:correctStrength(value)
	self:patchFloat(0x20, value)
end

function EquipParamWeapon:correctAgility(value)
	self:patchFloat(0x24, value)
end

function EquipParamWeapon:correctMagic(value)
	self:patchFloat(0x28, value)
end

function EquipParamWeapon:correctFaith(value)
	self:patchFloat(0x2C, value)
end

--Block Rate
function EquipParamWeapon:physGuardCutRate(value)
	self:patchFloat(0x30, value)
end

function EquipParamWeapon:magGuardCutRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamWeapon:fireGuardCutRate(value)
	self:patchFloat(0x38, value)
end

function EquipParamWeapon:thunGuardCutRate(value)
	self:patchFloat(0x3C, value)
end

-- Effects on hit
function EquipParamWeapon:spEffectBehaviorId(value)
	self:patch4Byte(0x40, value)
end

function EquipParamWeapon:spEffectBehaviorId1(value)
	self:patch4Byte(0x44, value)
end

function EquipParamWeapon:spEffectBehaviorId2(value)
	self:patch4Byte(0x48, value)
end

-- Effects on self
function EquipParamWeapon:residentSpEffectId(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamWeapon:residentSpEffectId1(value)
	self:patch4Byte(0x50, value)
end

function EquipParamWeapon:residentSpEffectId2(value)
	self:patch4Byte(0x54, value)
end

function EquipParamWeapon:materialSetId(value)
	self:patch4Byte(0x58, value)
end

--Origin Equip Weapon
function EquipParamWeapon:originEquipWep(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamWeapon:originEquipWep1(value)
	self:patch4Byte(0x60, value)
end

function EquipParamWeapon:originEquipWep2(value)
	self:patch4Byte(0x64, value)
end

function EquipParamWeapon:originEquipWep3(value)
	self:patch4Byte(0x68, value)
end

function EquipParamWeapon:originEquipWep4(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamWeapon:originEquipWep5(value)
	self:patch4Byte(0x70, value)
end

function EquipParamWeapon:originEquipWep6(value)
	self:patch4Byte(0x74, value)
end

function EquipParamWeapon:originEquipWep7(value)
	self:patch4Byte(0x78, value)
end

function EquipParamWeapon:originEquipWep8(value)
	self:patch4Byte(0x7C, value)
end

function EquipParamWeapon:originEquipWep9(value)
	self:patch4Byte(0x80, value)
end

function EquipParamWeapon:originEquipWep10(value)
	self:patch4Byte(0x84, value)
end

function EquipParamWeapon:originEquipWep11(value)
	self:patch4Byte(0x88, value)
end

function EquipParamWeapon:originEquipWep12(value)
	self:patch4Byte(0x8C, value)
end

function EquipParamWeapon:originEquipWep13(value)
	self:patch4Byte(0x90, value)
end

function EquipParamWeapon:originEquipWep14(value)
	self:patch4Byte(0x94, value)
end

function EquipParamWeapon:originEquipWep15(value)
	self:patch4Byte(0x98, value)
end

--Anti Damage Rate
function EquipParamWeapon:antiDemonDamageRate(value)
	self:patchFloat(0x9C, value)
end

function EquipParamWeapon:antUndeadDamageRate(value)
	self:patchFloat(0xA0, value)
end

function EquipParamWeapon:antHollowDamageRate(value)
	self:patchFloat(0xA4, value)
end

function EquipParamWeapon:antAbyssalDamageRate(value)
	self:patchFloat(0xA8, value)
end

-- AC-BA
function EquipParamWeapon:vagrantItemLotId(value)
	self:patch4Byte(0xAC, value)
end

function EquipParamWeapon:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xB0, value)
end

function EquipParamWeapon:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0xB4, value)
end

function EquipParamWeapon:equipModelId(value)
	self:patch2Byte(0xB8, value)
end

function EquipParamWeapon:iconId(value)
	self:patch2Byte(0xBA, value)
end

-- Durability
function EquipParamWeapon:durability(value)
	self:patch2Byte(0xBC, value)
end

function EquipParamWeapon:durabilityMax(value)
	self:patch2Byte(0xBE, value)
end

-- C0-C2
function EquipParamWeapon:attackThrowEscape(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamWeapon:parryDamageLife(value)
	self:patch2Byte(0xC2, value)
end

--Attack Damage
function EquipParamWeapon:attackBasePhysics(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamWeapon:attackBaseMagic(value)
	self:patch2Byte(0xC6, value)
end

function EquipParamWeapon:attackBaseFire(value)
	self:patch2Byte(0xC8, value)
end

function EquipParamWeapon:attackBaseThunder(value)
	self:patch2Byte(0xCA, value)
end

function EquipParamWeapon:attackBaseStamina(value) -- Stamina consuption to block
	self:patch2Byte(0xCC, value)
end

-- CE-ED
function EquipParamWeapon:saWeaponDamage(value)
	self:patch2Byte(0xCE, value)
end

function EquipParamWeapon:saDurability(value)
	self:patch2Byte(0xD0, value)
end

function EquipParamWeapon:guardAngle(value)
	self:patch2Byte(0xD2, value)
end

function EquipParamWeapon:staminaGuardDef(value)
	self:patch2Byte(0xD4, value)
end

function EquipParamWeapon:reinforceTypeId(value)
	self:patch2Byte(0xD6, value)
end

function EquipParamWeapon:trophySGradeId(value)
	self:patch2Byte(0xD8, value)
end

function EquipParamWeapon:trophySeqId(value)
	self:patch2Byte(0xDA, value)
end

function EquipParamWeapon:throwAtkRate(value)
	self:patch2Byte(0xDC, value)
end

function EquipParamWeapon:bowDistRate(value)
	self:patch2Byte(0xDE, value)
end

function EquipParamWeapon:equipModelCategory(value)
	self:patchByte(0xE0, value)
end

function EquipParamWeapon:equipModelGender(value)
	self:patchByte(0xE1, value)
end

function EquipParamWeapon:weaponCategory(value)
	self:patchByte(0xE2, value)
end

function EquipParamWeapon:wepmotionCategory(value)
	self:patchByte(0xE3, value)
end

function EquipParamWeapon:guardmotionCategory(value)
	self:patchByte(0xE4, value)
end

function EquipParamWeapon:atkMaterial(value)
	self:patchByte(0xE5, value)
end

function EquipParamWeapon:defMaterial(value)
	self:patchByte(0xE6, value)
end

function EquipParamWeapon:defSfxMaterial(value)
	self:patchByte(0xE7, value)
end

function EquipParamWeapon:correctType(value)
	self:patchByte(0xE8, value)
end

function EquipParamWeapon:spAttribute(value)
	self:patchByte(0xE9, value)
end

function EquipParamWeapon:spAtkcategory(value)
	self:patchByte(0xEA, value)
end

--[[
function EquipParamWeapon:?(value)
	self:patchByte(0xEB, value)
end
]]--

function EquipParamWeapon:wepmotionOneHandId(value)
	self:patchByte(0xEC, value)
end

function EquipParamWeapon:wepmotionBothHandId(value)
	self:patchByte(0xEE, value)
end

-- Requirements
function EquipParamWeapon:properStrength(value)
	self:patchByte(0xEE, value)
end

function EquipParamWeapon:properAgility(value)
	self:patchByte(0xEF, value)
end

function EquipParamWeapon:properMagic(value)
	self:patchByte(0xF0, value)
end

function EquipParamWeapon:properFaith(value)
	self:patchByte(0xF1, value)
end

-- F2-100

function EquipParamWeapon:overStrength(value)
	self:patchByte(0xF2, value)
end

function EquipParamWeapon:attackBaseParry(value)
	self:patchByte(0xF3, value)
end

function EquipParamWeapon:defenseBaseParry(value)
	self:patchByte(0xF4, value)
end

function EquipParamWeapon:guardBaseRepel(value)
	self:patchByte(0xF5, value)
end

function EquipParamWeapon:attackBaseRepel(value)
	self:patchByte(0xF6, value)
end

function EquipParamWeapon:guardCutCancelRate(value)
	self:patchByte(0xF7, value)
end

function EquipParamWeapon:guardLevel(value)
	self:patchByte(0xF8, value)
end

function EquipParamWeapon:slashGuardCutRate(value)
	self:patchByte(0xF9, value)
end

function EquipParamWeapon:blowGuardCutRate(value)
	self:patchByte(0xFA, value)
end

function EquipParamWeapon:thrustGuardCutRate(value)
	self:patchByte(0xFB, value)
end

function EquipParamWeapon:poisonGuardResist(value)
	self:patchByte(0xFC, value)
end

function EquipParamWeapon:diseaseGuardResist(value)
	self:patchByte(0xFD, value)
end

function EquipParamWeapon:bloodGuardResist(value)
	self:patchByte(0xFE, value)
end

function EquipParamWeapon:curseGuardResist(value)
	self:patchByte(0xFF, value)
end

function EquipParamWeapon:isDurabilityDivergence(value)
	self:patchByte(0x100, value)
end

-- Flags
-- 101
function EquipParamWeapon:rightHandEquipable(value)
	self:patchBinary(0x101, value, 0)
end

function EquipParamWeapon:leftHandEquipable(value)
	self:patchBinary(0x101, value, 1)
end

function EquipParamWeapon:bothHandEquipable(value)
	self:patchBinary(0x101, value, 2)
end

function EquipParamWeapon:arrowSlotEquipable(value)
	self:patchBinary(0x101, value, 3)
end

function EquipParamWeapon:boltSlotEquipable(value)
	self:patchBinary(0x101, value, 4)
end

function EquipParamWeapon:enableGuard(value)
	self:patchBinary(0x101, value, 5)
end

function EquipParamWeapon:enableParry(value)
	self:patchBinary(0x101, value, 6)
end

function EquipParamWeapon:enableMagic(value)
	self:patchBinary(0x101, value, 7)
end

-- 102
function EquipParamWeapon:enablePyromancy(value)
	self:patchBinary(0x102, value, 0)
end

function EquipParamWeapon:enableMiracle(value)
	self:patchBinary(0x102, value, 1)
end

function EquipParamWeapon:enableVowMagic(value)
	self:patchBinary(0x102, value, 2)
end

function EquipParamWeapon:isNormalAttackType(value)
	self:patchBinary(0x102, value, 3)
end

function EquipParamWeapon:isBlowAttackType(value)
	self:patchBinary(0x102, value, 4)
end

function EquipParamWeapon:isSlashAttackType(value)
	self:patchBinary(0x102, value, 5)
end

function EquipParamWeapon:isThrustAttackType(value)
	self:patchBinary(0x102, value, 6)
end

function EquipParamWeapon:isEnhance(value)
	self:patchBinary(0x102, value, 7)
end

-- 103
function EquipParamWeapon:isLuckCorrect(value)
	self:patchBinary(0x103, value, 0)
end

function EquipParamWeapon:isCustom(value)
	self:patchBinary(0x103, value, 1)
end

function EquipParamWeapon:disableBaseChangeReset(value)
	self:patchBinary(0x103, value, 2)
end

function EquipParamWeapon:disableRepair(value)
	self:patchBinary(0x103, value, 3)
end

function EquipParamWeapon:isDarkHand(value)
	self:patchBinary(0x103, value, 4)
end

function EquipParamWeapon:simpleModelForDlc(value)
	self:patchBinary(0x103, value, 5)
end

function EquipParamWeapon:ubytelanternWep(value)
	self:patchBinary(0x103, value, 6)
end

function EquipParamWeapon:isVersusGhostWep(value)
	self:patchBinary(0x103, value, 7)
end

--Changes the infusion icon
function EquipParamWeapon:baseChangeCategory(value)
	self:patchBinary(0x104, value, 0)
end

function EquipParamWeapon:isDragonSlayer(value)
	self:patchBinary(0x104, value, 1)
end

function EquipParamWeapon:isDeposit(value)
	self:patchBinary(0x104, value, 2)
end

function EquipParamWeapon:disableMultiDropShare(value)
	self:patchBinary(0x104, value, 3)
end

-- insert Unknown 1 104 Binary 4 - 180 here

function EquipParamWeapon:darkGuardCutRate(value)
	self:patchFloat(0x184, value)
end

function EquipParamWeapon:attackBaseDark(value)
	self:patch2Byte(0x188, value)
end

-- insert Unknown 2 18A-193 here

function EquipParamWeapon:swordArt(value)
	self:patch4Byte(0x194, value)
end


function EquipParamWeapon:correctLuck(value)
	self:patchFloat(0x198, value)
end

function EquipParamWeapon:scalingCategories(value)
	self:patch4Byte(0x228, value)
end
-- insert Unknown 3 197-258 here

--[[END EquipParamWeapon class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037703</ID>
                  <Description>"EquipParamProtector"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamProtector class]]--
EquipParamProtector = BaseParamClass:new()

function EquipParamProtector:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("EquipParamProtector", uuid, id, address)
	return o
end

function EquipParamProtector:sortId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamProtector:wanderingEquipId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamProtector:vagrantItemLotId(value)
	self:patch4Byte(0x8, value)
end

function EquipParamProtector:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0xC, value)
end

function EquipParamProtector:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x10, value)
end

--Prices
function EquipParamProtector:fixPrice(value)
	self:patch4Byte(0x14, value)
end

function EquipParamProtector:basicPrice(value)
	self:patch4Byte(0x18, value)
end

function EquipParamProtector:sellValue(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamProtector:weight(value)
	self:patchFloat(0x20, value)
end

--Effect On Equip
function EquipParamProtector:residentSpEffectId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamProtector:residentSpEffectId2(value)
	self:patch4Byte(0x28, value)
end

function EquipParamProtector:residentSpEffectId3(value)
	self:patch4Byte(0x2C, value)
end


function EquipParamProtector:materialSetId(value)
	self:patch4Byte(0x30, value)
end

function EquipParamProtector:partsDamageRate(value)
	self:patchFloat(0x34, value)
end

function EquipParamProtector:corectSARecover(value)
	self:patchFloat(0x38, value)
end

--Origin Equip Pros
function EquipParamProtector:originEquipPro(value)
	self:patch4Byte(0x3C, value)
end

function EquipParamProtector:originEquipPro1(value)
	self:patch4Byte(0x40, value)
end

function EquipParamProtector:originEquipPro2(value)
	self:patch4Byte(0x44, value)
end

function EquipParamProtector:originEquipPro3(value)
	self:patch4Byte(0x48, value)
end

function EquipParamProtector:originEquipPro4(value)
	self:patch4Byte(0x4C, value)
end

function EquipParamProtector:originEquipPro5(value)
	self:patch4Byte(0x50, value)
end

function EquipParamProtector:originEquipPro6(value)
	self:patch4Byte(0x54, value)
end

function EquipParamProtector:originEquipPro7(value)
	self:patch4Byte(0x58, value)
end

function EquipParamProtector:originEquipPro8(value)
	self:patch4Byte(0x5C, value)
end

function EquipParamProtector:originEquipPro9(value)
	self:patch4Byte(0x60, value)
end

function EquipParamProtector:originEquipPro10(value)
	self:patch4Byte(0x64, value)
end

function EquipParamProtector:originEquipPro11(value)
	self:patch4Byte(0x68, value)
end

function EquipParamProtector:originEquipPro12(value)
	self:patch4Byte(0x6C, value)
end

function EquipParamProtector:originEquipPro13(value)
	self:patch4Byte(0x70, value)
end

function EquipParamProtector:originEquipPro14(value)
	self:patch4Byte(0x74, value)
end

function EquipParamProtector:originEquipPro15(value)
	self:patch4Byte(0x78, value)
end


function EquipParamProtector:equipModelId(value)
	self:patch2Byte(0xA0, value)
end

function EquipParamProtector:iconIdM(value)
	self:patch2Byte(0xA2, value)
end

function EquipParamProtector:iconIdF(value)
	self:patch4Byte(0xA4, value)
end

function EquipParamProtector:knockbackBounceRate(value)
	self:patch2Byte(0xA8, value)
end

--Durability
function EquipParamProtector:durability(value)
	self:patch2Byte(0xAA, value)
end

function EquipParamProtector:durabilityMax(value)
	self:patch2Byte(0xAC, value)
end


function EquipParamProtector:saDurability(value)
	self:patch2Byte(0xAE, value)
end

--Resistence
function EquipParamProtector:resistPoison(value)
	self:patch2Byte(0xC0, value)
end

function EquipParamProtector:resistDisease(value)
	self:patch2Byte(0xC2, value)
end

function EquipParamProtector:resistBlood(value)
	self:patch2Byte(0xC4, value)
end

function EquipParamProtector:resistCurse(value)
	self:patchByte(0xC6, value)
end

--Defense
function EquipParamProtector:defensePhysical(value)
	self:patchFloat(0xE0, value)
end

function EquipParamProtector:defenseSlash(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseStrike(value)
	self:patchFloat(0xE8, value)
end

function EquipParamProtector:defenseThrust(value)
	self:patchFloat(0xEC, value)
end

function EquipParamProtector:defenseMagic(value)
	self:patchFloat(0xF0, value)
end

function EquipParamProtector:defenseFire(value)
	self:patchFloat(0xE4, value)
end

function EquipParamProtector:defenseThunder(value)
	self:patchFloat(0xE8, value)
end


function EquipParamProtector:poise(value)
	self:patchFloat(0x110, value)
end

function EquipParamProtector:defenseDark(value)
	self:patchFloat(0x118, value)
end

function EquipParamProtector:resistFrost(value)
	self:patch2Byte(0x12C, value)
end

--[[END EquipParamProtector class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037704</ID>
                  <Description>"EquipParamGoods"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamGoods class]]--
EquipParamGoods = BaseParamClass:new()

function EquipParamGoods:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("EquipParamGoods", uuid, id, address)
	return o
end

function EquipParamGoods:refId(value)
	self:patch4Byte(0x0, value)
end

function EquipParamGoods:sfxVariationId(value)
	self:patch4Byte(0x4, value)
end

function EquipParamGoods:weight(value)
	self:patchFloat(0x8, value)
end

function EquipParamGoods:basicPrice(value)
	self:patch4Byte(0xC, value)
end

function EquipParamGoods:sellValue(value)
	self:patch4Byte(0x10, value)
end

function EquipParamGoods:behaviorId(value)
	self:patch4Byte(0x14, value)
end

function EquipParamGoods:replaceItemId(value)
	self:patch4Byte(0x18, value)
end

function EquipParamGoods:sortId(value)
	self:patch4Byte(0x1C, value)
end

function EquipParamGoods:qwcId(value)
	self:patch4Byte(0x20, value)
end

function EquipParamGoods:yesNoDialogMessageId(value)
	self:patch4Byte(0x24, value)
end

function EquipParamGoods:magicId(value)
	self:patch4Byte(0x28, value)
end

function EquipParamGoods:iconId(value)
	self:patch2Byte(0x2C, value)
end

function EquipParamGoods:modelId(value)
	self:patch2Byte(0x2E, value)
end

function EquipParamGoods:shopLv(value)
	self:patch2Byte(0x30, value)
end

function EquipParamGoods:compTrophySedId(value)
	self:patch2Byte(0x32, value)
end

function EquipParamGoods:trophySeqId(value)
	self:patch2Byte(0x34, value)
end

function EquipParamGoods:maxNum(value)
	self:patch2Byte(0x36, value)
end

function EquipParamGoods:consumeHeroPoint(value)
	self:patchByte(0x38, value)
end

function EquipParamGoods:overDexterity(value)
	self:patchByte(0x39, value)
end

function EquipParamGoods:goodsType(value)
	self:patchByte(0x3A, value)
end

function EquipParamGoods:refCategory(value)
	self:patchByte(0x3B, value)
end

function EquipParamGoods:goodsCategory(value)
	self:patchByte(0x3C, value)
end

function EquipParamGoods:goodsUseAnim(value)
	self:patchByte(0x3E, value)
end

function EquipParamGoods:opmeMenuType(value)
	self:patchByte(0x3F, value)
end

function EquipParamGoods:useLimitCategory(value)
	self:patchByte(0x40, value)
end

function EquipParamGoods:replaceCategory(value)
	self:patchByte(0x41, value)
end

--Vow Types
function EquipParamGoods:vowType0(value)
	self:patchBinary(0x42, value, 0)
end

function EquipParamGoods:vowType1(value)
	self:patchBinary(0x42, value, 1)
end

function EquipParamGoods:vowType2(value)
	self:patchBinary(0x42, value, 2)
end

function EquipParamGoods:vowType3(value)
	self:patchBinary(0x42, value, 3)
end

function EquipParamGoods:vowType4(value)
	self:patchBinary(0x42, value, 4)
end

function EquipParamGoods:vowType5(value)
	self:patchBinary(0x42, value, 5)
end

function EquipParamGoods:vowType6(value)
	self:patchBinary(0x42, value, 6)
end

function EquipParamGoods:vowType7(value)
	self:patchBinary(0x42, value, 7)
end

function EquipParamGoods:vowType8(value)
	self:patchBinary(0x43, value, 0)
end

function EquipParamGoods:vowType9(value)
	self:patchBinary(0x43, value, 1)
end

function EquipParamGoods:vowType10(value)
	self:patchBinary(0x43, value, 2)
end

function EquipParamGoods:vowType11(value)
	self:patchBinary(0x43, value, 3)
end

function EquipParamGoods:vowType12(value)
	self:patchBinary(0x43, value, 4)
end

function EquipParamGoods:vowType13(value)
	self:patchBinary(0x43, value, 5)
end

function EquipParamGoods:vowType14(value)
	self:patchBinary(0x43, value, 6)
end

function EquipParamGoods:vowType15(value)
	self:patchBinary(0x43, value, 7)
end

--Flags
function EquipParamGoods:enable_live(value)
	self:patchBinary(0x44, value, 0)
end

function EquipParamGoods:enable_gray(value)
	self:patchBinary(0x44, value, 1)
end

function EquipParamGoods:enable_white(value)
	self:patchBinary(0x44, value, 2)
end

function EquipParamGoods:enable_black(value)
	self:patchBinary(0x44, value, 3)
end

function EquipParamGoods:enable_multi(value)
	self:patchBinary(0x44, value, 4)
end

function EquipParamGoods:disable_offline(value)
	self:patchBinary(0x44, value, 5)
end

function EquipParamGoods:isEquip(value)
	self:patchBinary(0x44, value, 6)
end

function EquipParamGoods:isConsume(value)
	self:patchBinary(0x44, value, 7)
end

function EquipParamGoods:isAutoEquip(value)
	self:patchBinary(0x45, value, 0)
end

function EquipParamGoods:isEstablishment(value)
	self:patchBinary(0x45, value, 1)
end

function EquipParamGoods:isOnlyOne(value)
	self:patchBinary(0x45, value, 2)
end

function EquipParamGoods:isDrop(value)
	self:patchBinary(0x45, value, 3)
end

function EquipParamGoods:isDeposit(value)
	self:patchBinary(0x45, value, 4)
end

function EquipParamGoods:isDisableHand(value)
	self:patchBinary(0x45, value, 5)
end

function EquipParamGoods:IsTravelItem(value)
	self:patchBinary(0x45, value, 6)
end

function EquipParamGoods:isSuppleItem(value)
	self:patchBinary(0x45, value, 7)
end

function EquipParamGoods:isFullSuppleItem(value)
	self:patchBinary(0x46, value, 0)
end

function EquipParamGoods:isEnhance(value)
	self:patchBinary(0x46, value, 1)
end

function EquipParamGoods:isFixItem(value)
	self:patchBinary(0x46, value, 2)
end

function EquipParamGoods:disableMultiDropShare(value)
	self:patchBinary(0x46, value, 3)
end

function EquipParamGoods:disableUseAtColiseum(value)
	self:patchBinary(0x46, value, 4)
end

function EquipParamGoods:disableUseAtOutOfColiseum(value)
	self:patchBinary(0x46, value, 5)
end


function EquipParamGoods:vagrantItemLotId(value)
	self:patch4Byte(0x50, value)
end

function EquipParamGoods:vagrantBonusEneDropItemLotId(value)
	self:patch4Byte(0x54, value)
end

function EquipParamGoods:vagrantItemEneDropItemLotId(value)
	self:patch4Byte(0x58, value)
end

--[[END EquipParamGoods class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037705</ID>
                  <Description>"SpEffectParam"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START SpEffectParam class]]--
SpEffectParam = BaseParamClass:new()

function SpEffectParam:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("SpEffectParam", uuid, id, address)
	return o
end

function SpEffectParam:iconId(value)
	self:patch4Byte(0x0, value)
end

function SpEffectParam:conditionHp(value)
	self:patchFloat(0x4, value)
end

function SpEffectParam:effectEndurance(value)
	self:patchFloat(0x8, value)
end

function SpEffectParam:motionInterval(value)
	self:patchFloat(0xC, value)
end

--Modifier
function SpEffectParam:maxHpRate(value)
	self:patchFloat(0x10, value)
end

function SpEffectParam:maxMpRate(value)
	self:patchFloat(0x14, value)
end

function SpEffectParam:maxStaminaRate(value)
	self:patchFloat(0x18, value)
end

--Damage Cut
function SpEffectParam:slashDamageCutRate(value)
	self:patchFloat(0x1C, value)
end

function SpEffectParam:blowDamageCutRate(value)
	self:patchFloat(0x20, value)
end

function SpEffectParam:thrustDamageCutRate(value)
	self:patchFloat(0x24, value)
end

function SpEffectParam:neutralDamageCutRate(value)
	self:patchFloat(0x28, value)
end

function SpEffectParam:magicDamageCutRate(value)
	self:patchFloat(0x2C, value)
end

function SpEffectParam:fireDamageCutRate(value)
	self:patchFloat(0x30, value)
end

function SpEffectParam:thunderDamageCutRate(value)
	self:patchFloat(0x34, value)
end

--Rate
function SpEffectParam:physicsAttackRate(value)
	self:patchFloat(0x38, value)
end

function SpEffectParam:magicAttackRate(value)
	self:patchFloat(0x3C, value)
end

function SpEffectParam:fireAttackRate(value)
	self:patchFloat(0x40, value)
end

function SpEffectParam:thunderAttackRate(value)
	self:patchFloat(0x44, value)
end

--Power Rate
function SpEffectParam:physicsAttackPowerRate(value)
	self:patchFloat(0x48, value)
end

function SpEffectParam:magicAttackPowerRate(value)
	self:patchFloat(0x4C, value)
end

function SpEffectParam:fireAttackPowerRate(value)
	self:patchFloat(0x50, value)
end

function SpEffectParam:thunderAttackPowerRate(value)
	self:patchFloat(0x54, value)
end

function SpEffectParam:physicsAttackPower(value)
	self:patch4Byte(0x58, value)
end

function SpEffectParam:magicAttackPower(value)
	self:patch4Byte(0x5C, value)
end

function SpEffectParam:fireAttackPower(value)
	self:patch4Byte(0x60, value)
end

function SpEffectParam:thunderAttackPower(value)
	self:patch4Byte(0x64, value)
end

--Diffence Rate
function SpEffectParam:physicsDiffenceRate(value)
	self:patchFloat(0x68, value)
end

function SpEffectParam:magicDiffenceRate(value)
	self:patchFloat(0x6C, value)
end

function SpEffectParam:fireDiffenceRate(value)
	self:patchFloat(0x70, value)
end

function SpEffectParam:thunderDiffenceRate(value)
	self:patchFloat(0x74, value)
end

function SpEffectParam:physicsDiffence(value)
	self:patch4Byte(0x78, value)
end

function SpEffectParam:magicDiffence(value)
	self:patch4Byte(0x7C, value)
end

function SpEffectParam:fireDiffence(value)
	self:patch4Byte(0x80, value)
end

function SpEffectParam:thunderDiffence(value)
	self:patch4Byte(0x84, value)
end

--Change Rare 1
function SpEffectParam:noGuardDamageRate(value)
	self:patchFloat(0x88, value)
end

function SpEffectParam:vitalSpotChangeRate(value)
	self:patchFloat(0x8C, value)
end

function SpEffectParam:normalSpotChangeRate(value)
	self:patchFloat(0x90, value)
end

function SpEffectParam:maxHpChangeRate(value)
	self:patchFloat(0x94, value)
end


function SpEffectParam:behaviorId(value)
	self:patch4Byte(0x98, value)
end

--Change Rare 2
function SpEffectParam:changeHpRate(value)
	self:patchFloat(0x9C, value)
end

function SpEffectParam:changeHpPoint(value)
	self:patch4Byte(0xA0, value)
end

function SpEffectParam:changeMpRate(value)
	self:patchFloat(0xA4, value)
end

function SpEffectParam:changeMpPoint(value)
	self:patch4Byte(0xA8, value)
end

function SpEffectParam:mpRecoverChangeSpeed(value)
	self:patch4Byte(0xAC, value)
end

function SpEffectParam:changeStaminaRate(value)
	self:patchFloat(0xB0, value)
end

function SpEffectParam:changeStaminaPoint(value)
	self:patch4Byte(0xB4, value)
end

function SpEffectParam:staminaRecoverChangeSpeed(value)
	self:patch4Byte(0xB8, value)
end


function SpEffectParam:magicEffectTimeChange(value)
	self:patchFloat(0xBC, value)
end

--Durability
function SpEffectParam:insideDurability(value)
	self:patch4Byte(0xC0, value)
end

function SpEffectParam:maxDurability(value)
	self:patch4Byte(0xC4, value)
end


function SpEffectParam:staminaAttackRate(value)
	self:patchFloat(0xC8, value)
end

function SpEffectParam:poizonAttackPower(value)
	self:patch4Byte(0xCC, value)
end

function SpEffectParam:registIllness(value)
	self:patch4Byte(0xD0, value)
end

function SpEffectParam:registBlood(value)
	self:patch4Byte(0xD4, value)
end

function SpEffectParam:registCurse(value)
	self:patch4Byte(0xD8, value)
end

function SpEffectParam:fallDamageRate(value)
	self:patchFloat(0xDC, value)
end

function SpEffectParam:soulRate(value)
	self:patchFloat(0xE0, value)
end

function SpEffectParam:equipWeightChangeRate(value)
	self:patchFloat(0xE4, value)
end

function SpEffectParam:allItemWeightChangeRate(value)
	self:patchFloat(0xE8, value)
end

function SpEffectParam:soul(value)
	self:patch4Byte(0xEC, value)
end

function SpEffectParam:animIdOffset(value)
	self:patch4Byte(0xF0, value)
end

function SpEffectParam:haveSoulRate(value)
	self:patchFloat(0xF4, value)
end

function SpEffectParam:targetPriority(value)
	self:patchFloat(0xF8, value)
end

function SpEffectParam:sightSearchEnemyCut(value)
	self:patch4Byte(0xFC, value)
end

function SpEffectParam:hearingSearchEnemyCut(value)
	self:patchFloat(0x100, value)
end

function SpEffectParam:grabityRate(value)
	self:patchFloat(0x104, value)
end

--Change Rate 3
function SpEffectParam:registPoizonChangeRate(value)
	self:patchFloat(0x108, value)
end

function SpEffectParam:registIllnessChangeRate(value)
	self:patchFloat(0x10C, value)
end

function SpEffectParam:registBloodChangeRate(value)
	self:patchFloat(0x110, value)
end

function SpEffectParam:registCurseChangeRate(value)
	self:patchFloat(0x114, value)
end


function SpEffectParam:soulStealRate(value)
	self:patchFloat(0x118, value)
end

function SpEffectParam:lifeReductionRate(value)
	self:patchFloat(0x11C, value)
end

function SpEffectParam:hpRecoverRate(value)
	self:patchFloat(0x120, value)
end

function SpEffectParam:replaceSpEffectId(value)
	self:patch4Byte(0x124, value)
end

function SpEffectParam:cycleOccurrenceSpEffectId(value)
	self:patch4Byte(0x128, value)
end

function SpEffectParam:atkOccurence(value)
	self:patch4Byte(0x12C, value)
end

function SpEffectParam:guardDefFlickPowerRate(value)
	self:patchFloat(0x130, value)
end

function SpEffectParam:guardStaminaCutRate(value)
	self:patchFloat(0x134, value)
end

function SpEffectParam:rayCastPassedTime(value)
	self:patch2Byte(0x138, value)
end

function SpEffectParam:changeSuperArmorPoint(value)
	self:patch2Byte(0x13A, value)
end

function SpEffectParam:bowDistRate(value)
	self:patch2Byte(0x13C, value)
end

function SpEffectParam:spCategory(value)
	self:patch2Byte(0x13E, value)
end

function SpEffectParam:categoryPriority(value)
	self:patchByte(0x140, value)
end

function SpEffectParam:saveCategory(value)
	self:patchByte(0x141, value)
end

function SpEffectParam:changeMagicSlot(value)
	self:patchByte(0x142, value)
end

function SpEffectParam:changeMiracleSlot(value)
	self:patchByte(0x143, value)
end

function SpEffectParam:heroPointDamage(value)
	self:patchByte(0x144, value)
end

function SpEffectParam:defFlickPower(value)
	self:patchByte(0x145, value)
end

function SpEffectParam:flickDamageCutRate(value)
	self:patchByte(0x146, value)
end

function SpEffectParam:bloodDamageRate(value)
	self:patchByte(0x147, value)
end

--Damage Level
function SpEffectParam:dmgLv_None(value)
	self:patchByte(0x148, value)
end

function SpEffectParam:dmgLv_S(value)
	self:patchByte(0x149, value)
end

function SpEffectParam:dmgLv_M(value)
	self:patchByte(0x14A, value)
end

function SpEffectParam:dmgLv_L(value)
	self:patchByte(0x14B, value)
end

function SpEffectParam:dmgLv_BlowM(value)
	self:patchByte(0x14C, value)
end

function SpEffectParam:dmgLv_Push(value)
	self:patchByte(0x14D, value)
end

function SpEffectParam:dmgLv_Strike(value)
	self:patchByte(0x14E, value)
end

function SpEffectParam:dmgLv_BlowS(value)
	self:patchByte(0x14F, value)
end

function SpEffectParam:dmgLv_Min(value)
	self:patchByte(0x150, value)
end

function SpEffectParam:dmgLv_Uppercut(value)
	self:patchByte(0x151, value)
end

function SpEffectParam:dmgLv_BlowLL(value)
	self:patchByte(0x152, value)
end

function SpEffectParam:dmgLv_Breath(value)
	self:patchByte(0x153, value)
end


function SpEffectParam:atkAttribute(value)
	self:patchByte(0x154, value)
end

function SpEffectParam:spAttribute(value)
	self:patchByte(0x155, value)
end

function SpEffectParam:stateInfo(value)
	self:patchByte(0x156, value)
end

function SpEffectParam:wepParamChange(value)
	self:patchByte(0x157, value)
end

function SpEffectParam:moveType(value)
	self:patchByte(0x158, value)
end

function SpEffectParam:lifeReductionType(value)
	self:patchByte(0x159, value)
end

function SpEffectParam:throwCondition(value)
	self:patchByte(0x15A, value)
end

function SpEffectParam:addBehaviorJudgeId_condition(value)
	self:patchByte(0x15B, value)
end

function SpEffectParam:addBehaviorJudgeId_add(value)
	self:patchByte(0x15C, value)
end

-- insert Minor 1 here

-- insert Unknown here

function SpEffectParam:frostAttackPower(value)
	self:patch4Byte(0x1AC, value)
end

function SpEffectParam:darkDamageCutRate(value)
	self:patchFloat(0x1D4, value)
end

function SpEffectParam:darkDifferenceRate(value)
	self:patchFloat(0x1D8, value)
end

function SpEffectParam:darkAttackPower(value)
	self:patch4Byte(0x1E4, value)
end

function SpEffectParam:registFrostChange(value)
	self:patch4Byte(0x2BC, value)
end

--Buff's
function SpEffectParam:vigorBuff(value)
	self:patchByte(0x308, value)
end

function SpEffectParam:attunementBuff(value)
	self:patchByte(0x309, value)
end

function SpEffectParam:enduranceBuff(value)
	self:patchByte(0x30A, value)
end

function SpEffectParam:vitalityBuff(value)
	self:patchByte(0x30B, value)
end

function SpEffectParam:strenghtBuff(value)
	self:patchByte(0x30C, value)
end

function SpEffectParam:dextrerityBuff(value)
	self:patchByte(0x30D, value)
end

function SpEffectParam:intelligenceBuff(value)
	self:patchByte(0x30E, value)
end

function SpEffectParam:faithBuff(value)
	self:patchByte(0x30F, value)
end

function SpEffectParam:luckBuff(value)
	self:patchByte(0x310, value)
end

--[[END SpEffectParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037706</ID>
                  <Description>"Magic"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Magic class]]--
Magic = BaseParamClass:new()

function Magic:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("Magic", uuid, id, address)
	return o
end

function Magic:YesNoDialogBox(value)
	self:patchByte(0x0, value)
end

function Magic:LimitCancelSpEffectID(value)
	self:patch4Byte(0x4, value)
end

function Magic:SortID(value)
	self:patch2Byte(0x8, value)
end

function Magic:ReferenceID(value)
	self:patch2Byte(0xA, value)
end

function Magic:FPCost(value)
	self:patch2Byte(0xC, value)
end

function Magic:StaminaCost(value)
	self:patch2Byte(0xE, value)
end

function Magic:IconID(value)
	self:patch2Byte(0x10, value)
end

function Magic:BehaviorID(value)
	self:patch2Byte(0x12, value)
end

function Magic:MaterialItemID(value)
	self:patch2Byte(0x14, value)
end

function Magic:ReplaceMagicID(value)
	self:patch2Byte(0x16, value)
end

function Magic:NumberofCasts(value)
	self:patch2Byte(0x18, value)
end

function Magic:Humanity(value)
	self:patchByte(0x1A, value)
end

function Magic:OverDexterity(value)
	self:patchByte(0x1B, value)
end

function Magic:SFXVariation(value)
	self:patchByte(0x1C, value)
end

function Magic:SlotsUsed(value)
	self:patchByte(0x1D, value)
end

function Magic:RequiredINT(value)
	self:patchByte(0x1E, value)
end

function Magic:RequiredFAI(value)
	self:patchByte(0x1F, value)
end

function Magic:DexterityMinimumCastSpeedScaling(value)
	self:patchByte(0x20, value)
end

function Magic:DexterityMaximumCastSpeedScaling(value)
	self:patchByte(0x21, value)
end

function Magic:EzStateBehaviorType(value)
	self:patchByte(0x22, value)
end

function Magic:ReferenceCategory(value)
	self:patchByte(0x23, value)
end

function Magic:SpEffectCategory(value)
	self:patchByte(0x24, value)
end

function Magic:CastAnimation(value)
	self:patchByte(0x25, value)
end

function Magic:MenuType(value)
	self:patchByte(0x26, value)
end

function Magic:HasSpEffectType(value)
	self:patchByte(0x27, value)
end

function Magic:ReplaceCategory(value)
	self:patchByte(0x28, value)
end

function Magic:UseLimitCategory(value)
	self:patchByte(0x29, value)
end

-- insert Vow Types 1 here

function Magic:EnableMulti(value)
	self:patchBinary(0x2B, value, 0)
end

function Magic:EnableMultOnly(value)
	self:patchBinary(0x2B, value, 1)
end

function Magic:IsWeaponEnchant(value)
	self:patchBinary(0x2B, value, 2)
end

function Magic:IsShieldEnchant(value)
	self:patchBinary(0x2B, value, 3)
end

function Magic:EnableHuman(value)
	self:patchBinary(0x2B, value, 4)
end

function Magic:EnableDragonPhantom(value)
	self:patchBinary(0x2B, value, 5)
end

function Magic:EnableWhitePhantom(value)
	self:patchBinary(0x2B, value, 6)
end

function Magic:EnableBlackPhantom(value)
	self:patchBinary(0x2B, value, 7)
end

function Magic:DisableOffline(value)
	self:patchBinary(0x2C, value, 0)
end

function Magic:UsesMiracleResonance(value)
	self:patchBinary(0x2C, value, 1)
end

-- insert Vow Types 2 here

-- insert 2E-2F

function Magic:sfxID1(value)
	self:patch4Byte(0x30, value)
end

function Magic:sfxID2(value)
	self:patch4Byte(0x34, value)
end

function Magic:sfxID3(value)
	self:patch4Byte(0x38, value)
end

-- insert 3C-40

--Faith Breakpoints
function Magic:FaithBreakpoint20(value)
	self:patchByte(0x41, value)
end

function Magic:FaithBreakpoint30(value)
	self:patchByte(0x42, value)
end

function Magic:FaithBreakpoint40(value)
	self:patchByte(0x43, value)
end

function Magic:FaithBreakpoint60(value)
	self:patchByte(0x44, value)
end

-- insert 45-47


--Spell cast at X Faith
function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x48, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x4C, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x50, value)
end

function Magic:Spellcastat20Faith(value)
	self:patch4Byte(0x54, value)
end

-- insert 58-60

-- Bullets
function Magic:Bullet1(value)
	self:patch4Byte(0x64, value)
end

function Magic:Bullet2(value)
	self:patch4Byte(0x68, value)
end

function Magic:Bullet3(value)
	self:patch4Byte(0x6C, value)
end

-- insert 6C

function Magic:Bullet4(value)
	self:patch4Byte(0x70, value)
end

--[[END Magic class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037707</ID>
                  <Description>"Bullet"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START Bullet class]]--
Bullet = BaseParamClass:new()

function Bullet:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("Bullet", uuid, id, address)
	return o
end

function Bullet:atkId_Bullet(value)
	self:patch4Byte(0x0, value)
end

function Bullet:sfxId_Bullet(value)
	self:patch4Byte(0x4, value)
end

function Bullet:sfxId_Hit(value)
	self:patch4Byte(0x8, value)
end

function Bullet:sfxId_Flick(value)
	self:patch4Byte(0xC, value)
end

function Bullet:life(value)
	self:patchFloat(0x10, value)
end

function Bullet:dist(value)
	self:patchFloat(0x14, value)
end

function Bullet:shootInterval(value)
	self:patchFloat(0x18, value)
end

function Bullet:gravityInRange(value)
	self:patch4Byte(0x1C, value)
end

function Bullet:gravityOutRange(value)
	self:patchFloat(0x20, value)
end

function Bullet:hormingStopRange(value)
	self:patchFloat(0x24, value)
end

function Bullet:initVellocity(value)
	self:patchFloat(0x28, value)
end

function Bullet:accelInRange(value)
	self:patchFloat(0x2C, value)
end

function Bullet:accelOutRange(value)
	self:patchFloat(0x30, value)
end

function Bullet:maxVellocity(value)
	self:patchFloat(0x34, value)
end

function Bullet:minVellocity(value)
	self:patchFloat(0x38, value)
end

function Bullet:accelTime(value)
	self:patchFloat(0x3C, value)
end

function Bullet:homingBeginDist(value)
	self:patchFloat(0x40, value)
end

function Bullet:hitRadius(value)
	self:patchFloat(0x44, value)
end

function Bullet:hitRadiusMax(value)
	self:patchFloat(0x48, value)
end

function Bullet:spreadTime(value)
	self:patchFloat(0x4C, value)
end

function Bullet:expDelay(value)
	self:patchFloat(0x50, value)
end

function Bullet:hormingOffsetRange(value)
	self:patchFloat(0x54, value)
end

function Bullet:dmgHitRecordLifeTime(value)
	self:patchFloat(0x58, value)
end

function Bullet:externalForce(value)
	self:patch4Byte(0x5C, value)
end

function Bullet:spEffectIDForShooter(value)
	self:patch4Byte(0x60, value)
end

function Bullet:autoSearchNPCThinkID(value)
	self:patch4Byte(0x64, value)
end

function Bullet:HitBulletID(value)
	self:patch4Byte(0x68, value)
end

--Special Effect IDs
function Bullet:spEffectId0(value)
	self:patch4Byte(0x6C, value)
end

function Bullet:spEffectId1(value)
	self:patch4Byte(0x70, value)
end

function Bullet:spEffectId2(value)
	self:patch4Byte(0x74, value)
end

function Bullet:spEffectId3(value)
	self:patch4Byte(0x78, value)
end

function Bullet:spEffectId4(value)
	self:patch4Byte(0x7C, value)
end

function Bullet:numShoot(value)
	self:patch2Byte(0x80, value)
end

function Bullet:homingAngle(value)
	self:patch2Byte(0x82, value)
end

function Bullet:shootAngle(value)
	self:patch2Byte(0x84, value)
end

function Bullet:shootAngleInterval(value)
	self:patch2Byte(0x86, value)
end

function Bullet:shootAngleXInterval(value)
	self:patch2Byte(0x88, value)
end

--Damp's
function Bullet:damageDamp(value)
	self:patchByte(0x8A, value)
end

function Bullet:spelDamageDamp(value)
	self:patchByte(0x8B, value)
end

function Bullet:fireDamageDamp(value)
	self:patchByte(0x8C, value)
end

function Bullet:thunderDamageDamp(value)
	self:patchByte(0x8D, value)
end

function Bullet:staminaDamp(value)
	self:patchByte(0x8E, value)
end

function Bullet:knockbackDamp(value)
	self:patchByte(0x8F, value)
end


function Bullet:shootAngleXZ(value)
	self:patchByte(0x90, value)
end

function Bullet:lockShootLimitAng(value)
	self:patchByte(0x91, value)
end

function Bullet:isPenetrate(value)
	self:patchByte(0x92, value)
end

function Bullet:prevVelocityDirRate(value)
	self:patchByte(0x93, value)
end

function Bullet:atkAttribute(value)
	self:patchByte(0x94, value)
end

function Bullet:spAttribute(value)
	self:patchByte(0x95, value)
end

function Bullet:Material_AttackType(value)
	self:patchByte(0x96, value)
end

function Bullet:Material_AttackMaterial(value)
	self:patchByte(0x97, value)
end

function Bullet:Material_Size(value)
	self:patchByte(0x99, value)
end

function Bullet:launchConditionType(value)
	self:patchByte(0x99, value)
end

--Falgs
function Bullet:FollowType(value)
	self:patchBinary(0x9A, value, 0)
end

function Bullet:EmittePosType(value)
	self:patchBinary(0x9A, value, 1)
end

function Bullet:isAttackSFX(value)
	self:patchBinary(0x9A, value, 2)
end

function Bullet:isEndlessHit(value)
	self:patchBinary(0x9A, value, 3)
end

function Bullet:isPenetrateMap(value)
	self:patchBinary(0x9B, value, 0)
end

function Bullet:isHitBothTeam(value)
	self:patchBinary(0x9B, value, 1)
end

function Bullet:isUseSharedHitList(value)
	self:patchBinary(0x9B, value, 2)
end

function Bullet:isUseMultiDmyPolyIfPlace(value)
	self:patchBinary(0x9B, value, 3)
end

function Bullet:attachEffectType(value)
	self:patchBinary(0x9B, value, 4)
end

function Bullet:isHitForceBullet(value)
	self:patchBinary(0x9B, value, 5)
end

function Bullet:isIgnoreSfxIfHitWater(value)
	self:patchBinary(0x9B, value, 6)
end

function Bullet:isIgnoreMoveStateIfHitWater(value)
	self:patchBinary(0x9B, value, 7)
end

function Bullet:isHitDarkForceBullet(value)
	self:patchBinary(0x9C, value, 0)
end

-- insert Unknown binary flags 1-7 for 0x9C

--[[END Bullet class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037708</ID>
                  <Description>"BehaviorParam_PC"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START BehaviorParam_PC class]]--
BehaviorParam_PC = BaseParamClass:new()

function BehaviorParam_PC:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("BehaviorParam_PC", uuid, id, address)
	return o
end

function BehaviorParam_PC:variationId(value)
	self:patch4Byte(0x0, value)
end

function BehaviorParam_PC:behaviorJudgeId(value)
	self:patch4Byte(0x4, value)
end

function BehaviorParam_PC:ezStateBehaviorType_old(value)
	self:patchByte(0x8, value)
end

function BehaviorParam_PC:refType(value)
	self:patchByte(0x9, value)
end

function BehaviorParam_PC:refId(value)
	self:patch4Byte(0xC, value)
end

function BehaviorParam_PC:sfxVariationId(value)
	self:patch4Byte(0x10, value)
end

function BehaviorParam_PC:stamina(value)
	self:patch4Byte(0x14, value)
end

function BehaviorParam_PC:mp(value)
	self:patch4Byte(0x18, value)
end

function BehaviorParam_PC:category(value)
	self:patchByte(0x1C, value)
end

function BehaviorParam_PC:heroPoint(value)
	self:patchByte(0x1D, value)
end

function BehaviorParam_PC:pad1(value)
	self:patchByte(0x1E, value)
end

-- insert 0x1F here

--[[END BehaviorParam_PC class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037709</ID>
                  <Description>"AtkParam_Pc"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START AtkParam_Pc class]]--
AtkParam_Pc = BaseParamClass:new()

function AtkParam_Pc:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("AtkParam_Pc", uuid, id, address)
	return o
end

function AtkParam_Pc:Hit0_Radius(value)
	self:patchFloat(0x0, value)
end

function AtkParam_Pc:Hit1_Radius(value)
	self:patchFloat(0x4, value)
end

function AtkParam_Pc:Hit2_Radius(value)
	self:patchFloat(0x8, value)
end

function AtkParam_Pc:Hit3_Radius(value)
	self:patchFloat(0xC, value)
end

function AtkParam_Pc:KnockbackDist(value)
	self:patchFloat(0x10, value)
end

function AtkParam_Pc:HitStopTime(value)
	self:patchFloat(0x14, value)
end

--Special Effect IDs
function AtkParam_Pc:SpecialEffectId0(value)
	self:patch4Byte(0x18, value)
end

function AtkParam_Pc:SpecialEffectId1(value)
	self:patch4Byte(0x1C, value)
end

function AtkParam_Pc:SpecialEffectId2(value)
	self:patch4Byte(0x20, value)
end

function AtkParam_Pc:SpecialEffectId3(value)
	self:patch4Byte(0x24, value)
end

function AtkParam_Pc:SpecialEffectId4(value)
	self:patch4Byte(0x28, value)
end

--Hit DmyPoly
function AtkParam_Pc:Hit0_DmyPoly1(value)
	self:patch2Byte(0x2C, value)
end

function AtkParam_Pc:Hit1_DmyPoly1(value)
	self:patch2Byte(0x2E, value)
end

function AtkParam_Pc:Hit2_DmyPoly1(value)
	self:patch2Byte(0x30, value)
end

function AtkParam_Pc:Hit3_DmyPoly1(value)
	self:patch2Byte(0x32, value)
end

function AtkParam_Pc:Hit0_DmyPoly2(value)
	self:patch2Byte(0x34, value)
end

function AtkParam_Pc:Hit1_DmyPoly2(value)
	self:patch2Byte(0x36, value)
end

function AtkParam_Pc:Hit2_DmyPoly2(value)
	self:patch2Byte(0x38, value)
end

function AtkParam_Pc:Hit3_DmyPoly2(value)
	self:patch2Byte(0x3A, value)
end
--

function AtkParam_Pc:BlowingCorrection(value)
	self:patch2Byte(0x3C, value)
end

--Corrections
function AtkParam_Pc:AtkPhysCorrection(value)
	self:patch2Byte(0x3E, value)
end

function AtkParam_Pc:AtkMagCorrection(value)
	self:patch2Byte(0x40, value)
end

function AtkParam_Pc:AtkFireCorrection(value)
	self:patch2Byte(0x42, value)
end

function AtkParam_Pc:AtkThunCorrection(value)
	self:patch2Byte(0x44, value)
end

function AtkParam_Pc:AtkStamCorrection(value)
	self:patch2Byte(0x46, value)
end

function AtkParam_Pc:GuardAtkRateCorrection(value)
	self:patch2Byte(0x48, value)
end

function AtkParam_Pc:GuardBreakCorrection(value)
	self:patch2Byte(0x4A, value)
end

function AtkParam_Pc:AtkThrowEscapeCorrection(value)
	self:patch2Byte(0x4C, value)
end

function AtkParam_Pc:AtkSuperArmorCorrection(value)
	self:patch2Byte(0x4E, value)
end
--

--Attack
function AtkParam_Pc:AtkPhys(value)
	self:patch2Byte(0x50, value)
end

function AtkParam_Pc:AtkMag(value)
	self:patch2Byte(0x52, value)
end

function AtkParam_Pc:AtkFire(value)
	self:patch2Byte(0x54, value)
end

function AtkParam_Pc:AtkThun(value)
	self:patch2Byte(0x56, value)
end

function AtkParam_Pc:AtkStam(value)
	self:patch2Byte(0x58, value)
end

function AtkParam_Pc:GuardAtkRate(value)
	self:patch2Byte(0x5A, value)
end

function AtkParam_Pc:GuardBreakRate(value)
	self:patch2Byte(0x5C, value)
end

function AtkParam_Pc:AtkSuperArmor(value)
	self:patch2Byte(0x5E, value)
end

function AtkParam_Pc:AtkThrowEscape(value)
	self:patch2Byte(0x60, value)
end

function AtkParam_Pc:AtkObj(value)
	self:patch2Byte(0x62, value)
end
--

function AtkParam_Pc:GuardStaminaCutRate(value)
	self:patch2Byte(0x64, value)
end

function AtkParam_Pc:GuardRate(value)
	self:patch2Byte(0x66, value)
end

function AtkParam_Pc:ThrowTypeId(value)
	self:patch2Byte(0x68, value)
end

--Hit Type
function AtkParam_Pc:Hit0_hitType(value)
	self:patchByte(0x6A, value)
end

function AtkParam_Pc:Hit1_hitType(value)
	self:patchByte(0x6B, value)
end

function AtkParam_Pc:Hit2_hitType(value)
	self:patchByte(0x6C, value)
end

function AtkParam_Pc:Hit3_hitType(value)
	self:patchByte(0x6D, value)
end


-- insert Unknown 1 6E-71

function AtkParam_Pc:DamageLevel(value)
	self:patchByte(0x72, value)
end

function AtkParam_Pc:MapHitType(value)
	self:patchByte(0x73, value)
end

function AtkParam_Pc:GuardCutCancelRate(value)
	self:patchByte(0x74, value)
end

function AtkParam_Pc:AtkAttribute(value)
	self:patchByte(0x75, value)
end

function AtkParam_Pc:SpecialAttributes(value)
	self:patchByte(0x76, value)
end

function AtkParam_Pc:AttackType(value)
	self:patchByte(0x77, value)
end

function AtkParam_Pc:AtkMaterial(value)
	self:patchByte(0x78, value)
end

function AtkParam_Pc:AtkSize(value)
	self:patchByte(0x79, value)
end

function AtkParam_Pc:DefMaterial(value)
	self:patchByte(0x7A, value)
end

function AtkParam_Pc:DefSfxMaterial(value)
	self:patchByte(0x7B, value)
end

function AtkParam_Pc:HitSourceType(value)
	self:patchByte(0x7C, value)
end

function AtkParam_Pc:ThrowFlag(value)
	self:patchByte(0x7D, value)
end

-- insert Unknown 2 7E-1A4 here

--[[END AtkParam_Pc class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037710</ID>
                  <Description>"ThrowParam"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START ThrowParam class]]--
ThrowParam = BaseParamClass:new()

function ThrowParam:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("ThrowParam", uuid, id, address)
	return o
end

function ThrowParam:AtkChrId(value)
	self:patch4Byte(0x0, value)
end

function ThrowParam:DefChrId(value)
	self:patch4Byte(0x4, value)
end

function ThrowParam:Dist(value)
	self:patchFloat(0x8, value)
end

function ThrowParam:DiffAngMin(value)
	self:patchFloat(0xC, value)
end

function ThrowParam:DiffAngMax(value)
	self:patchFloat(0x10, value)
end

function ThrowParam:UpperYRange(value)
	self:patchFloat(0x14, value)
end

function ThrowParam:LowerYRange(value)
	self:patchFloat(0x18, value)
end

function ThrowParam:DiffAngMyToDef(value)
	self:patchFloat(0x1C, value)
end

function ThrowParam:ThrowTypeId(value)
	self:patch4Byte(0x20, value)
end

function ThrowParam:AtkAnimId(value)
	self:patch4Byte(0x24, value)
end

function ThrowParam:DefAnimId(value)
	self:patch4Byte(0x28, value)
end

function ThrowParam:EscHp(value)
	self:patch2Byte(0x2C, value)
end

function ThrowParam:SelfEscCycleTime(value)
	self:patch2Byte(0x2E, value)
end

function ThrowParam:SphereCastRadiusRateTop(value)
	self:patch2Byte(0x30, value)
end

function ThrowParam:SphereCastRadiusRateLow(value)
	self:patch2Byte(0x32, value)
end

function ThrowParam:PadType(value)
	self:patchByte(0x34, value)
end

function ThrowParam:AtkEnableState(value)
	self:patchByte(0x35, value)
end

function ThrowParam:AtkSorbDmyId(value)
	self:patchByte(0x36, value)
end

function ThrowParam:DefSorbDmyId(value)
	self:patchByte(0x37, value)
end

function ThrowParam:ThrowType(value)
	self:patchByte(0x38, value)
end

function ThrowParam:SelfEscCycleCnt(value)
	self:patchByte(0x39, value)
end

function ThrowParam:DmyHasChrDirType(value)
	self:patchByte(0x3A, value)
end

-- insert 3B-7C here

--[[END ThrowParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037711</ID>
                  <Description>"SwordArtsParam"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START SwordArtsParam class]]--
SwordArtsParam = BaseParamClass:new()

function SwordArtsParam:new(uuid, id, address)
    local o = {}
    self.__index = self
    setmetatable(o, self)

    o:init("SwordArtsParam", uuid, id, address)
    return o
end

function SwordArtsParam:WeaponArtId(value)
    self:patchByte(0x0,value)
end

function SwordArtsParam:FPcost(value)
    self:patch2Byte(0xE,value)
end

function SwordArtsParam:R1FP(value)
    self:patch2Byte(0x10,value)
end

function SwordArtsParam:R2FP(value)
    self:patch2Byte(0x12,value)
end
--[[END SwordArtsParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037712</ID>
                  <Description>"EquipParamAccessory"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START EquipParamAccessory class]]--
EquipParamAccessory = BaseParamClass:new()

function EquipParamAccessory:new(uuid, id, address)
    local o = {}
    self.__index = self
    setmetatable(o, self)

    o:init("EquipParamAccessory", uuid, id, address)
    return o
end

function EquipParamAccessory:refId(value)
    self:patch4Byte(0x0, value)
end

function EquipParamAccessory:sfxVariation(value)
    self:patch4Byte(0x4, value)
end

function EquipParamAccessory:weight(value)
    self:patchFloat(0x8, value)
end

function EquipParamAccessory:behaviorId(value)
    self:patch4Byte(0xC, value)
end

function EquipParamAccessory:basicPrice(value)
    self:patch4Byte(0x10, value)
end

function EquipParamAccessory:sellValue(value)
    self:patch4Byte(0x14, value)
end

function EquipParamAccessory:sortId(value)
    self:patch4Byte(0x18, value)
end

function EquipParamAccessory:qwcId(value)
    self:patch4Byte(0x1C, value)
end

function EquipParamAccessory:equipModelId(value)
    self:patch2Byte(0x20, value)
end

function EquipParamAccessory:iconId(value)
    self:patch2Byte(0x22, value)
end

function EquipParamAccessory:shopLv(value)
    self:patch2Byte(0x24, value)
end

function EquipParamAccessory:trophySGradeId(value)
    self:patch2Byte(0x26, value)
end

function EquipParamAccessory:trophySeqId(value)
    self:patch2Byte(0x28, value)
end

function EquipParamAccessory:equipModelCategory(value)
    self:patchByte(0x2A, value)
end

function EquipParamAccessory:equipModelGender(value)
    self:patchByte(0x2B, value)
end

function EquipParamAccessory:accessoryCategory(value)
    self:patchByte(0x2C, value)
end

function EquipParamAccessory:refCategory(value)
    self:patchByte(0x2D, value)
end

function EquipParamAccessory:spEffectCategory(value)
    self:patchByte(0x2E, value)
end
--[[END EquipParamAccessory class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>1337037713</ID>
                  <Description>"SpEffectVfxParam"</Description>
                  <Options moHideChildren="1"/>
                  <LastState/>
                  <Color>000000</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

--[[START SpEffectVfxParam class]]--
SpEffectVfxParam = BaseParamClass:new()

function SpEffectVfxParam:new(uuid, id, address)
	local o = {}
	self.__index = self
	setmetatable(o, self)

	o:init("SpEffectVfxParam", uuid, id, address)
	return o
end

function SpEffectVfxParam:midstSfxID(value)
    self:patch4Byte(0x0, value)
end

function SpEffectVfxParam:midstSeID(value)
    self:patch4Byte(0x4, value)
end

function SpEffectVfxParam:initSfxID(value)
    self:patch4Byte(0x8, value)
end

function SpEffectVfxParam:InitSeID(value)
    self:patch4Byte(0xC, value)
end

function SpEffectVfxParam:FinishSfxID(value)
    self:patch4Byte(0x10, value)
end

function SpEffectVfxParam:FinishSeID(value)
    self:patch4Byte(0x14, value)
end

function SpEffectVfxParam:camouflageBeginDist(value)
    self:patchFloat(0x18, value)
end

function SpEffectVfxParam:camouflageEndDist(value)
    self:patchFloat(0x1C, value)
end

function SpEffectVfxParam:transformProtectorID(value)
    self:patch4Byte(0x20, value)
end

function SpEffectVfxParam:midstDmyID(value)
    self:patch2Byte(0x24, value)
end

function SpEffectVfxParam:initDmyID(value)
    self:patch2Byte(0x26, value)
end

function SpEffectVfxParam:FinishDmyID(value)
    self:patch2Byte(0x28, value)
end

function SpEffectVfxParam:EffectType(value)
    self:patchByte(0x2A, value)
end

function SpEffectVfxParam:SoulParamIDForWepEnchant(value)
    self:patchByte(0x2B, value)
end

function SpEffectVfxParam:PlayCategory(value)
    self:patchByte(0x2C, value)
end

function SpEffectVfxParam:PlayPriority(value)
    self:patchByte(0x2D, value)
end

function SpEffectVfxParam:ExistEffectForLarge(value)
    self:patchBinary(0x2E, value , 0)
end

function SpEffectVfxParam:ExistEffectForSoul(value)
    self:patchBinary(0x2E, value , 1)
end

function SpEffectVfxParam:EffectInvisibleAtCamouflage(value)
    self:patchBinary(0x2E, value , 2)
end

function SpEffectVfxParam:useCamouflage(value)
    self:patchBinary(0x2E, value , 3)
end

function SpEffectVfxParam:InvisibleAtFriendCamouflage(value)
    self:patchBinary(0x2E, value , 4)
end

function SpEffectVfxParam:addMapAreaBlock(value)
    self:patchBinary(0x2E, value , 5)
end

function SpEffectVfxParam:halfCamouflage(value)
    self:patchBinary(0x2E, value , 6)
end

function SpEffectVfxParam:isFullBodyTransformProtectorID(value)
    self:patchBinary(0x2E, value , 7)
end

function SpEffectVfxParam:IsInvisibleWeapon(value)
    self:patchBinary(0x2F, value , 0)
end

function SpEffectVfxParam:IsSilence(value)
    self:patchBinary(0x2F, value , 1)
end
--[[END SpEffectVfxParam class]]--

[DISABLE]
{$lua}
if syntaxcheck then return end
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>1337037715</ID>
          <Description>"Weapons"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1337036854</ID>
              <Description>"Washing Pole Fix"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if not syntaxcheck then
local Weapon = {
      {5010000,0xC4,"74 00"},
      {5010100,0xC4,"74 00"},
      {5010200,0xC4,"74 00"},
      {5010300,0xC4,"74 00"},
      {5010400,0xC4,"74 00"},
      {5010500,0xC4,"74 00"},
      {5010600,0xC4,"74 00"},
      {5010700,0xC4,"74 00"},
      {5010800,0xC4,"74 00"},
      {5010900,0xC4,"74 00"},
      {5011000,0xC4,"74 00"},
      {5011100,0xC4,"74 00"},
      {5011200,0xC4,"74 00"},
      {5011300,0xC4,"74 00"},
      {5011400,0xC4,"74 00"},
      {5011500,0xC4,"74 00"},
}

paramUtils:paramIterator("EquipParamWeapon",Weapon,"WashingPoleDefault")
end

{$asm}
[DISABLE]
{$lua}
if not syntaxcheck then

paramUtils:paramDepatcher("WashingPoleDefault")
end
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337036853</ID>
              <Description>"Darkmoon Bow Fix"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if not syntaxcheck then
local Weapon = {
      {14130000,0x28,"00 00 8C 42"},
}
local Bullet = {
      {557,0x68,"68 0C D1 00"},
      {13700200,0x0,"88 70 AC 00"},
}

paramUtils:paramIterator("EquipParamWeapon",Weapon,"DarkmoonBowDefault")
paramUtils:paramIterator("Bullet",Bullet,"DarkmoonBowWABulletDefault")
end

{$asm}
[DISABLE]
{$lua}
if not syntaxcheck then
paramUtils:paramDepatcher("DarkmoonBowDefault")
paramUtils:paramDepatcher("DarkmoonBowWABulletDefault")
end
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037720</ID>
              <Description>"Dragonslayer Spear Fix"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local DragonSlayerSpear = EquipParamWeapon:new("DSSpear",9220000)
DragonSlayerSpear:attackBaseThunder(50)

local LightningCharge = SpEffectParam:new("DSSpear",130092200)
LightningCharge:effectEndurance(60)
LightningCharge:thunderAttackPower(40)
LightningCharge:patchBinary(0x160,1,5) --bAdjustFaithAblity

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restore("DSSpear")
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>1337037719</ID>
          <Description>"Armor"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1337037718</ID>
              <Description>"Armor Tweaks"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local armors = {}
--[[ BASIC FORMAT:
armors[decimal armorID] = {durability,weight,poise,
                        poison res,toxic (Disease) res,bleed res,curse res,frost res,
                        phys def, slash def,strike def,thrust def,magic def,fire def,thunder def,dark def}

i.e. Wolnir's Crown:
armors[57500000] = {270,3.4,0.982,
                    29,29,18,37,27,
                    0.969,0.969,0.969,0.972,0.961,0.957,0.955,0.951}
]]

for i,arr in pairs(armors) do
  local armorPatch = EquipParamProtector:new("ArmorTweaks",i)
  armorPatch:durabilityMax(arr[1])
  armorPatch:weight(arr[2])
  armorPatch:poise(arr[3])
  armorPatch:resistPoison(arr[4])
  armorPatch:resistDisease(arr[5])
  armorPatch:resistBlood(arr[6])
  armorPatch:resistCurse(arr[7])
  armorPatch:resistFrost(arr[8])
  armorPatch:defensePhysical(arr[9])
  armorPatch:defenseSlash(arr[10])
  armorPatch:defenseStrike(arr[11])
  armorPatch:defenseThrust(arr[12])
  armorPatch:defenseMagic(arr[13])
  armorPatch:defenseFire(arr[14])
  armorPatch:defenseThunder(arr[15])
  armorPatch:defenseDark(arr[16])
end
[DISABLE]
{$lua}
if not syntaxcheck then
  paramUtils:restore("ArmorTweaks")
end
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>1337037722</ID>
          <Description>"Spells"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1337037721</ID>
              <Description>"Fire Surge Fix"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if not syntaxcheck then
local Spell = {
      {2405000,0x1B,"FF"},
      {2405000,0x20,"FF"},
      {2405000,0x21,"FF"},
}

paramUtils:paramIterator("Magic",Spell,"FireSurgeDefault")
end

{$asm}
[DISABLE]
{$lua}
if not syntaxcheck then
paramUtils:paramDepatcher("FireSurgeDefault")
end
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037723</ID>
              <Description>"Floating Chaos"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>//WIP, needs testing
[ENABLE]
{$lua}
if syntaxcheck then return end
local FloatingChaosVisual = Bullet:new("floatingChaosEdit",12457000)
FloatingChaosVisual:life(22)

local FloatingChaosEmitter = Bullet:new("floatingChaosEdit",12457100)
FloatingChaosEmitter:life(22)
FloatingChaosEmitter:patchFloat(0xB0,4) --emitter interval
FloatingChaosEmitter:patchFloat(0xB4,4) --emitter interval
FloatingChaosEmitter:patchFloat(0xBC,2) --emitter delay until first shot

local FloatingChaosProjectile = Bullet:new("floatingChaosEdit",12457110)
FloatingChaosProjectile:hormingStopRange(0.4)
FloatingChaosProjectile:homingAngle(35)

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restore("floatingChaosEdit")
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037727</ID>
              <Description>"Way of White Corona"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local coronas = {
  13556000, 13556010, 13556021
}
for i,id in ipairs(coronas) do
local WoWCoronaAttack = AtkParam_Pc:new("coronaAttack",id)
WoWCoronaAttack:AtkPhysCorrection(120)
WoWCoronaAttack:AtkPhys(170)
end

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restore("coronaAttack")
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037724</ID>
              <Description>"Lifehunt Scythe"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local attack = {
--Lifehunt Scythe
  {13730000,0x188,"14 01"}, --AtkDark 276
  {13730000,0x1C,"D0 1B 2C 06"}, --spEffectId1	103554000
  {13730005,0x188,"14 01"}, --AtkDark 276
  {13730005,0x1C,"D0 1B 2C 06"}, --spEffectId1	103554000
--Faith 20
  {13730100,0x188,"6A 01"}, --AtkDark 362
  {13730100,0x1C,"D0 1B 2C 06"}, --spEffectId1	103554000
  {13730105,0x188,"6A 01"}, --AtkDark 362
  {13730105,0x1C,"D0 1B 2C 06"}, --spEffectId1	103554000
--Faith 30
  {13730200,0x188,"82 01"}, --AtkDark 386
  {13730200,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
  {13730205,0x188,"82 01"}, --AtkDark 386
  {13730205,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
--Faith 40
  {13730300,0x188,"9A 01"}, --AtkDark 410
  {13730300,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
  {13730305,0x188,"9A 01"}, --AtkDark 410
  {13730305,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
--Faith 60
  {13730400,0x188,"A8 01"}, --AtkDark 424
  {13730400,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
  {13730405,0x188,"A8 01"}, --AtkDark 424
  {13730405,0x1C,"B8 1F 2C 06"}, --spEffectId1	103555000
}
paramUtils:paramIterator("AtkParam_Pc",attack,"lifehuntAttack")

local effect = {
--Lifehunt Scythe
  {103731000,0xA0,"78 FF FF FF"}, --ChangeHPPoint -136
--Faith 20
  {103731100,0xA0,"6E FF FF FF"}, --ChangeHPPoint -146
--Faith 30
  {103731200,0xA0,"64 FF FF FF"}, --ChangeHPPoint -156
--Faith 40
  {103731300,0xA0,"5A FF FF FF"}, --ChangeHPPoint -166
--Faith 60
  {103731400,0xA0,"50 FF FF FF"}, --ChangeHPPoint -176
}
paramUtils:paramIterator("SpEffectParam",effect,"lifehuntEffect")

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:paramDepatcher("lifehuntAttack")
paramUtils:paramDepatcher("lifehuntEffect")
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037725</ID>
              <Description>"Dark Weapon"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local DarkBlade = SpEffectParam:new("darkBladeBuff",103640000)
DarkBlade:patch4Byte(0x1E8,60) --darkAttackPower
DarkBlade:patchBinary(0x160,1,4) --bAdjustMagicAblity

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restore("darkBladeBuff")
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>1337037726</ID>
              <Description>"Blessed Weapon"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end
local BlessedWeapon = SpEffectParam:new("blessedWeaponBuff",103640000)
BlessedWeapon:effectEndurance(60)
BlessedWeapon:physicsAttackPowerRate(1)
BlessedWeapon:physicsAttackPower(30)
BlessedWeapon:changeHpPoint(-4)

[DISABLE]
{$lua}
if syntaxcheck then return end
paramUtils:restore("blessedWeaponBuff")
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>1337037716</ID>
          <Description>"Development Tools"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>1337037717</ID>
              <Description>"Armor Value Finder"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{
  Author: AlchemyMouse
  Description: Put an armor and it'll dump what you need into the output,
               just copy that into the main armor script and edit as needed
}
[ENABLE]
{$lua}
if syntaxcheck then return end

local armorID = 57500000 --Armor you want
---------------------------DONT CHANGE------------------------------------------
function round(num)
  return math.floor(num * 1000 + 0.5) / 1000
end

local idTable = paramUtils:getParamIdTable("EquipParamProtector")
local address = idTable[armorID]

local weight = round(readFloat(address + "32"))
local poise = round(readFloat(address + "272"))
local durability = byteTableToWord(readBytes(address + "172",2,true))
local resistPoison = byteTableToWord(readBytes(address + "192",2,true))
local resistDisease = byteTableToWord(readBytes(address + "194",2,true))
local resistBlood = byteTableToWord(readBytes(address + "196",2,true))
local resistCurse = readBytes(address + "198",1)
local resistFrost = byteTableToWord(readBytes(address + "300",2,true))
local defensePhysical = round(readFloat(address + "224"))
local defenseSlash = round(readFloat(address + "228"))
local defenseStrike = round(readFloat(address + "232"))
local defenseThrust = round(readFloat(address + "236"))
local defenseMagic = round(readFloat(address + "240"))
local defenseFire = round(readFloat(address + "244"))
local defenseThunder = round(readFloat(address + "248"))
local defenseDark = round(readFloat(address + "280"))

local name = "Wolnir's Crown" --INDEV: figure out how to auto-grab this

--print("--" .. armorName)   INDEV
print("armors[" .. armorID .. "] = {" ..
      durability .. "," ..
      weight .. "," ..
      poise .. ",")
print("                    " ..
      resistPoison .. "," ..
      resistDisease .. "," ..
      resistBlood .. "," ..
      resistCurse .. "," ..
      resistFrost .. ",")
print("                    " ..
      defensePhysical .. "," ..
      defenseSlash .. "," ..
      defenseStrike .. "," ..
      defenseThrust .. "," ..
      defenseMagic .. "," ..
      defenseFire .. "," ..
      defenseThunder .. "," ..
      defenseDark .. "}")

[DISABLE]
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>ParamPatchBase</Name>
      <Address>1404EA050</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
</CheatTable>
